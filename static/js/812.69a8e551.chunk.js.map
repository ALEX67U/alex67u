{"version":3,"file":"static/js/812.69a8e551.chunk.js","mappings":"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","sources":["components/YouTubeEmbed.js","components/page/Article_4.js","components/videoMP4.js","webpack://alex67u/./src/components/page/Article.module.css?2dd3","webpack://alex67u/./src/components/videoMP4.module.css?c78e"],"sourcesContent":["import React from 'react';\r\nimport styles from './videoMP4.module.css'; \r\n\r\nconst YouTubeEmbed = ({ videoId }) => {\r\n    const embedUrl = `https://www.youtube.com/embed/${videoId}`;\r\n    return (\r\n        <div className={styles.videoContainer}>\r\n            <iframe\r\n                className={styles.video} \r\n                src={embedUrl}\r\n                title=\"YouTube video player\"\r\n                allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\r\n                allowFullScreen\r\n            ></iframe>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default YouTubeEmbed;\r\n","import React from 'react';\r\nimport styles from './Article.module.css';\r\nimport VideoMP4 from '../videoMP4';\r\nimport YouTubeEmbed from '../YouTubeEmbed';\r\n\r\nconst page = () => {\r\n  return (\r\n    <div className={styles.article}>\r\n        \r\n        <VideoMP4 filePath={`${process.env.PUBLIC_URL}/data/video/3Dprocedural.mp4`} />\r\n\r\n        <div className= {`${styles.paragraph_50} ${styles.padding1em}`} >\r\n          <h3 className={styles.subtitle}>Pourquoi un nouveau projet 3D en Java ?</h3>\r\n          <p>\r\n            Après avoir déjà réalisé un projet similaire en C++, j’ai décidé de repartir sur la création d'un moteur 3D en Java pour explorer d'autres approches techniques et affiner mes compétences en optimisation.\r\n            L’utilisation de Java avec OpenGL m’offre la possibilité de réévaluer certaines méthodes, tout en travaillant sur un environnement où la gestion mémoire et les outils disponibles diffèrent de ceux du C++.\r\n          </p>\r\n          <p>\r\n            Mon objectif n’est pas de réinventer la roue, mais plutôt de découvrir et d’expérimenter des techniques que je n’avais pas explorées auparavant. Vous pouvez voir le résultat de mon moteur actuelle dans cette vidéo.\r\n          </p>\r\n        </div>\r\n\r\n        <h3 className={styles.subtitle}>Le coût en temps et en mémoire d’un triangle avec OpenGL</h3>\r\n\r\n        <div className= {styles.paragraph_100} >\r\n          <p>\r\n          Avant de parler des techniques que j'ai utilisé ou que je souhaiterais mettre en place, je veux prendre le temps de mettre les bases, car comprendre le coût en temps et en mémoire d’un simple triangle est essentiel pour optimiser l’ensemble du rendu.\r\n          </p>\r\n          <p>\r\n          En OpenGL, un triangle est représenté par trois sommets, chacun ayant des attributs tels que la position, la couleur, la normale, et éventuellement des coordonnées de texture.\r\n          Le stockage en mémoire d’un triangle inclut ces données pour chaque sommet. Par exemple, si chaque sommet contient trois composantes pour la position (x, y, z) et trois pour la couleur (r, g, b), on stocke déjà 18 valeurs flottantes, soit 72 octets par triangle (en supposant que chaque valeur flottante occupe 4 octets).\r\n          À cela peuvent s’ajouter des données supplémentaires, comme des normales pour l’éclairage ou des coordonnées de texture, ce qui augmente encore l’utilisation mémoire.\r\n          </p>\r\n        </div>\r\n\r\n        <div className={styles.paragraph_50}>\r\n            <img className={styles.paragraph_100} src={process.env.PUBLIC_URL + '/data/images/Vertex.png'} alt=\"Vertex.png\"></img>\r\n        </div>\r\n\r\n        <div className= {styles.paragraph_50} >\r\n          <p>\r\n          En ce qui concerne le coût en temps, le rendu d’un triangle implique plusieurs étapes, notamment le passage des données du CPU au GPU, les transformations géométriques, la rasterisation et enfin l’application des shaders.\r\n          Chaque triangle traité passe par ces étapes, ce qui peut rapidement devenir coûteux en termes de performances lorsque leur nombre augmente.\r\n          </p>\r\n          <p>\r\n          L’optimisation à ce niveau repose souvent sur la réduction du nombre de triangles à rendre, en utilisant des techniques comme le culling (exclusion des triangles non visibles) ou la simplification de modèles pour limiter la complexité géométrique.\r\n          </p>\r\n        </div>\r\n\r\n        <div className={styles.paragraph_100}>\r\n          <p>\r\n          En somme, bien que chaque triangle individuel semble léger en termes de coût, leur multiplication dans une scène 3D peut entraîner une augmentation exponentielle de la consommation de mémoire et du temps de calcul, ce qui rend l’optimisation cruciale dans un moteur 3D.\r\n          </p>\r\n        </div>\r\n\r\n        <h3 className={styles.subtitle}>Le monde en voxel : une matrice 3D</h3>\r\n        <div className={styles.paragraph_50}>\r\n          <p>\r\n          Un voxel (élément volumétrique) est à la 3D ce que le pixel est à la 2D.\r\n          C’est une unité de volume dans un espace divisé en une grille tridimensionnelle.\r\n          </p>\r\n          <p>\r\n          Les mondes en voxels sont utilisés dans de nombreux contextes, notamment pour les jeux vidéo où l’environnement est construit à partir de blocs cubiques.\r\n          Cette technique permet de créer des paysages, des terrains, et bien plus encore.\r\n          </p>\r\n          \r\n        </div>\r\n        <div className={`${styles.paragraph_50} ${styles.margincontent}`}>\r\n            <img className={styles.paragraph_50} src={process.env.PUBLIC_URL + '/data/images/Voxelgitter.png'} alt=\"Voxelgitter.png\"></img>\r\n        </div>\r\n        <div className={styles.paragraph_100}>\r\n          <p>\r\n          Cependant, contrairement aux moteurs classiques qui utilisent des cubes standardisés pour chaque voxel, j’ai opté pour une méthode un peu plus complexe.\r\n          </p>\r\n        </div>\r\n\r\n        <h3 className={styles.subtitle}>Un système de voxels sans cubes prédéfinis</h3>\r\n        <div className={styles.paragraph_100}>\r\n          <p>\r\n          Dans la plupart des moteurs basés sur des voxels, chaque voxel est représenté par un simple cube.\r\n          Cette approche est populaire car elle simplifie grandement les calculs et facilite l’optimisation.\r\n          </p>\r\n          <p>\r\n          Pour mon projet, j’ai choisi de ne pas me limiter à cette structure cubique.\r\n          Mon système de voxels repose sur des points définis dans un intervalle [0.0, 1.0] en 3 dimensions, ce qui permet d’avoir plus de flexibilité dans les formes générées.\r\n          </p>\r\n          <p>\r\n          Cette approche augmente la complexité des calculs et de l’optimisation, mais elle ouvre aussi la porte à des configurations plus diversifiées.\r\n          </p>\r\n        </div>\r\n\r\n        <h3 className={styles.subtitle}>Gestion des chunks et vers un système d’octree</h3>\r\n        <div className={styles.paragraph_100}>\r\n          <p>\r\n            Actuellement, mon moteur utilise une gestion classique par chunks. Un chunk regroupe plusieurs voxels, ce qui facilite la gestion de grandes zones dans le monde 3D. Les chunks sont des blocs de données de taille fixe, ce qui permet de diviser l’espace de manière cohérente et de rendre uniquement les parties nécessaires à l’affichage.\r\n          </p>\r\n          <p>\r\n            Cependant, cette approche atteint rapidement ses limites dans des scènes plus complexes ou dynamiques. La méthode par chunks impose de charger et de rendre des sections entières, même si une grande partie des voxels ne sont pas visibles ou utiles pour la scène actuelle. Cette inefficacité m’a amené à réfléchir à une autre méthode : l’utilisation d’un octree.\r\n          </p>\r\n        </div>\r\n        <div className={styles.paragraph_50}>\r\n          <p>\r\n            L’octree est une structure de données hiérarchique que j'ai découverte lors de mes cours à l'UFR MIM. Il divise l’espace en cellules (ou nœuds) de plus en plus petites à mesure qu’on descend dans la hiérarchie. Chaque nœud peut contenir jusqu'à huit sous-nœuds, ce qui permet d’adapter la granularité de la division en fonction de la complexité locale du monde 3D.\r\n          </p>\r\n          <p>\r\n            Cette approche est particulièrement avantageuse pour gérer les scènes où une grande partie de l’espace est vide ou peu détaillée. Par exemple, dans un monde voxel, si une région est vide ou uniforme, l’octree peut représenter cette région avec un seul nœud, économisant ainsi à la fois en calculs et en mémoire.\r\n          </p>\r\n        </div>\r\n\r\n        <div className={`${styles.paragraph_50} ${styles.margincontent}`}>\r\n            <img className={styles.paragraph_100} src={process.env.PUBLIC_URL + '/data/images/Octree2.png'} alt=\"Octree2.png\"></img>\r\n        </div>\r\n\r\n        <div className={styles.paragraph_100}>\r\n          <p>\r\n            De plus, l'octree facilite l’exclusion des éléments non visibles grâce à un processus appelé \"frustum culling\", où seules les cellules pertinentes pour le champ de vision actuel sont rendues. Cela réduit considérablement le nombre de voxels à traiter par le GPU, améliorant ainsi la performance globale du moteur.\r\n          </p>\r\n          <p>\r\n            En résumé, en passant d’une gestion par chunks à un système d’octree, l’objectif est de mieux adapter la complexité des calculs aux besoins réels de la scène. Plutôt que de rendre systématiquement de grands blocs de voxels, l'octree permet une gestion plus granulaire et optimisée, en ne chargeant que les parties cruciales pour le rendu.\r\n          </p>\r\n        </div>\r\n\r\n        <h3 className={styles.subtitle}>Un projet en cours axé sur l'exploration technique</h3>\r\n        <div className={styles.paragraph_100}>\r\n          <p>\r\n            Ce projet n’a pas pour but de devenir un jeu ou un produit finalisé.\r\n            Il s’agit avant tout d’un terrain d’expérimentation où je teste différentes techniques d’optimisation et de rendu 3D.\r\n          </p>\r\n          <p>\r\n            Le développement est en constante évolution, et je continue d’apprendre en mettant en œuvre des solutions nouvelles et en réévaluant celles que j’ai déjà explorées.\r\n          </p>\r\n          <p>\r\n            C’est un projet personnel, principalement motivé par l’envie de mieux comprendre les défis liés à la création d’un moteur 3D, la gestion d’un monde procédural et surtout l'optimisation d'un système complexe!\r\n          </p>\r\n        </div>\r\n\r\n        <h3 className={styles.subtitle}>Quelques références</h3>\r\n        <div className={styles.paragraph_100}>\r\n          <p>\r\n            Si vous souhaitez en savoir plus sur les systèmes de voxels, la gestion des chunks, ou tout autres choses en rapport, voici quelques ressources que j'ai trouvées intéressantes et utiles pour mes recherches : (la majorité de ces ressources que je partage sont exclusivement en anglais)\r\n          </p>\r\n        </div>\r\n        <YouTubeEmbed videoId=\"4QOcCGI6xOU\" />\r\n        <YouTubeEmbed videoId=\"-POwgollFeY\" />\r\n        <YouTubeEmbed videoId=\"z_Q0sA3wE10\" />\r\n        <YouTubeEmbed videoId=\"7zqvtVCZNaw\" />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default page;","import React from 'react';\r\nimport styles from './videoMP4.module.css'; \r\n\r\nconst videoMP4 = ({ filePath }) => {\r\n  return (\r\n    <div className={styles.videoContainer}>\r\n      <video \r\n        className={styles.video} \r\n        controls\r\n\r\n      >\r\n        <source src={filePath} type=\"video/mp4\" />\r\n        Votre navigateur ne supporte pas la balise vidéo.\r\n      </video>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default videoMP4;\r\n","// extracted by mini-css-extract-plugin\nexport default {\"article\":\"Article_article__+gNQy\",\"subtitle\":\"Article_subtitle__lXQXQ\",\"paragraph_50\":\"Article_paragraph_50__pJ95J\",\"padding1em\":\"Article_padding1em__kEm6Q\",\"paragraph_100\":\"Article_paragraph_100__LJbdS\",\"margincontent\":\"Article_margincontent__+cw48\",\"maxcontent\":\"Article_maxcontent__umvPg\",\"list\":\"Article_list__KhP-C\"};","// extracted by mini-css-extract-plugin\nexport default {\"videoContainer\":\"videoMP4_videoContainer__jR5fp\",\"video\":\"videoMP4_video__LG6aT\"};"],"names":["_ref","videoId","embedUrl","concat","_jsx","className","styles","videoContainer","children","video","src","title","allow","allowFullScreen","page","_jsxs","article","VideoMP4","filePath","process","paragraph_50","padding1em","subtitle","paragraph_100","alt","margincontent","YouTubeEmbed","controls","type"],"sourceRoot":""}