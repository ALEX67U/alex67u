{"version":3,"file":"static/js/240.a08142e1.chunk.js","mappings":"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","sources":["components/YouTubeEmbed.js","components/page/Article_8.js","components/videoMP4.js","webpack://alex67u/./src/components/page/Article.module.css?2dd3","webpack://alex67u/./src/components/videoMP4.module.css?c78e"],"sourcesContent":["import React from 'react';\r\nimport styles from './videoMP4.module.css'; \r\n\r\nconst YouTubeEmbed = ({ videoId }) => {\r\n    const embedUrl = `https://www.youtube.com/embed/${videoId}`;\r\n    return (\r\n        <div className={styles.videoContainer}>\r\n            <iframe\r\n                className={styles.video} \r\n                src={embedUrl}\r\n                title=\"YouTube video player\"\r\n                allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\r\n                allowFullScreen\r\n            ></iframe>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default YouTubeEmbed;\r\n","import React from 'react';\r\nimport styles from './Article.module.css';\r\nimport VideoMP4 from '../videoMP4';\r\nimport YouTubeEmbed from '../YouTubeEmbed';\r\n\r\nconst page = () => {\r\n  return (\r\n    <div className={styles.article}>     \r\n        <VideoMP4 filePath={`${process.env.PUBLIC_URL}/data/video/3Drendu.mp4`} />\r\n        <div className={`${styles.paragraph_50} ${styles.padding1em}`}>\r\n          <h4>Exemple de rendu</h4>\r\n          <p>\r\n            Cette vidéo à réalisée à l'aide du logiciel OBS. Comme le rendu 3D est calculé en temps réel en parallèle avec l'enregistrement vidéo, il y a une légère latence de la video due aux performances limitées de mon ordinateur, qui est équipé uniquement d'un GPU Intel intégré. Cela a impactée la fluidité de la capture video.\r\n          </p>\r\n        </div>\r\n\r\n        <p className={styles.paragraph_100}> \r\n            Dans cette vidéo, on peut voir plusieurs formes simples en 3D qui mettent en pratique des concepts essentiels comme l'éclairage, les shaders, les matériaux et la projection d'ombres via les Shadow Maps. En parallèle, j'ai également expérimenté d'autres effets graphiques, comme les Normal Maps, le Parallax Mapping et des effets de post-traitement comme le Bloom, pour améliorer l’aspect visuel. Ces fonctionnalités ne sont pas toutes visibles dans cette capture mais ont été testées séparément durant le développement.\r\n        </p>\r\n\r\n        <h3 className={styles.subtitle}>1. Choix d'OpenGL</h3>\r\n        <div className={styles.paragraph_50}>\r\n          <h4>1.1 Pourquoi OpenGL ?</h4>\r\n          <p>\r\n              J'ai choisi <a href='https://www.opengl.org/'>OpenGL</a> comme bibliothèque graphique principale pour ce projet en raison de sa maturité et de sa popularité dans le domaine du développement 3D. En tant que norme ouverte largement adoptée, OpenGL est compatible avec la plupart des systèmes d'exploitation, ce qui en fait un excellent choix pour développer des applications multiplateformes. De plus, la richesse de sa documentation et l'énorme communauté de développeurs sont des atouts précieux pour résoudre les problèmes techniques et améliorer mes compétences.\r\n          </p>\r\n        </div>\r\n        <div className={styles.paragraph_50}>\r\n            <img className={styles.paragraph_100} src={process.env.PUBLIC_URL + '/data/images/opengl_logo.jpg'} alt=\"opengl_logo.jpg\"></img>\r\n        </div>\r\n\r\n        <div className={styles.paragraph_100}>\r\n          <h4>1.2 Les avantages de l'approche bas niveau</h4>\r\n          <p>\r\n              Contrairement à d'autres bibliothèques plus haut niveau, OpenGL offre un contrôle direct sur le pipeline graphique, ce qui permet une meilleure compréhension de ce qui se passe à chaque étape du rendu. Cette approche bas niveau, bien que plus complexe, m'a permis de personnaliser les moindres détails de mon moteur de rendu et d’apprendre en profondeur des concepts clés comme la gestion des tampons (buffers) et l'interaction avec les shaders.\r\n          </p>\r\n        </div>\r\n\r\n        <h3 className={styles.subtitle}>2. Comment marche la 3D</h3>\r\n\r\n        <div className={styles.paragraph_100}>\r\n          <h4>2.1 La représentation des objets en 3D</h4>\r\n          <p>\r\n              En programmation 3D, chaque objet est constitué de sommets, qui sont des points définis dans un espace tridimensionnel à l’aide de coordonnées X, Y et Z. Ces sommets sont ensuite connectés pour former des triangles, l’unité de base du rendu 3D. Le rendu final est une projection de ces triangles sur un plan 2D (l’écran), selon une certaine perspective.\r\n          </p>\r\n        </div>\r\n\r\n        <div className={`${styles.paragraph_100} ${styles.margincontent}`}>\r\n            <img className={styles.paragraph_50} src={process.env.PUBLIC_URL + '/data/images/icos.gif'} alt=\"icos.gif\"></img>\r\n        </div>\r\n\r\n        <div className={styles.paragraph_100}>\r\n          <h4>2.2 Les transformations géométriques</h4>\r\n          <p>\r\n            Pour manipuler les objets dans la scène, il est nécessaire d’appliquer des transformations géométriques comme la translation, la rotation et le redimensionnement. Ces transformations sont réalisées à l'aide de matrices (de 4x4 dans un espace homogène) qui permettent de déplacer, orienter et redimensionner les objets dans l'espace 3D. Ces matrices sont ensuite combinées pour former la matrice de transformation finale qui est appliquée à chaque sommet de l'objet.\r\n          </p>\r\n        </div>\r\n\r\n        <div className={styles.paragraph_100}>\r\n          <h4>2.3 La caméra et la perspective</h4>\r\n          <p>\r\n            La caméra virtuelle joue un rôle crucial dans le rendu 3D. Elle définit le point de vue depuis lequel la scène est observée. Deux matrices clés sont utilisées pour la projection en 3D : la matrice de vue, qui simule le positionnement et l'orientation de la caméra, et la matrice de projection, qui gère la manière dont les objets sont projetés sur l'écran (projection perspective ou orthographique).\r\n          </p>\r\n        </div>\r\n\r\n        <h3 className={styles.subtitle}>3. Les shaders, lumière et matériaux</h3>\r\n\r\n        <div className={styles.paragraph_100}>\r\n          <h4>3.1 Introduction aux shaders</h4>\r\n          <p>\r\n            Les shaders sont des programmes exécutés directement sur le GPU pour traiter chaque sommet ou chaque pixel de l'image. Dans OpenGL, on distingue principalement deux types de shaders : le vertex shader, qui s’occupe de la transformation des sommets, et le fragment shader, qui détermine la couleur finale de chaque pixel. La possibilité de programmer ces shaders en GLSL (OpenGL Shading Language) offre une grande flexibilité pour personnaliser l'apparence visuelle des objets.\r\n          </p>\r\n        </div>\r\n\r\n        <div className={styles.paragraph_100}>\r\n          <h4>3.2 Techniques d’éclairage</h4>\r\n          <p>\r\n            L'éclairage est un élément fondamental pour donner du réalisme à une scène 3D. J'ai implémenté plusieurs types de lumières : directionnelle (comme la lumière du soleil), ponctuelle (comme une ampoule) et par spot (comme un projecteur). Chaque type de lumière a ses propres caractéristiques, influençant la manière dont elle éclaire les objets et produit des ombres. En appliquant le modèle d'éclairage de Phong, qui combine les composantes diffuse, ambiante et spéculaire, j'ai pu obtenir un rendu lumineux crédible.\r\n          </p>\r\n        </div>\r\n\r\n        <div className={styles.paragraph_100}>\r\n          <h4>3.3 Matériaux et textures</h4>\r\n          <p>\r\n            Les matériaux déterminent l’apparence de surface des objets en contrôlant des propriétés telles que la réflexion, la brillance et la texture. En utilisant des textures 2D, il est possible de simuler des détails complexes comme des motifs ou des reliefs sans augmenter le nombre de polygones. J'ai intégré la gestion des textures dans le fragment shader, permettant d’associer des images à la surface des objets pour enrichir visuellement la scène.\r\n          </p>\r\n        </div>\r\n\r\n        <h3 className={styles.subtitle}>4. Techniques de projection d'ombre : Shadow Mapping</h3>\r\n\r\n        <div className={styles.paragraph_50}>\r\n          <h4>4.1 Principe du Shadow Mapping</h4>\r\n          <p>\r\n            Le Shadow Mapping est une technique courante pour générer des ombres en temps réel. Elle repose sur l'idée de capturer une \"vue\" de la scène depuis la source lumineuse et de stocker les distances des objets à cette lumière dans une texture appelée Shadow Map. Lors du rendu final, cette Shadow Map est consultée pour déterminer si un pixel est ombragé ou non, en comparant sa distance à la lumière avec celle enregistrée dans la carte.\r\n          </p>\r\n          <h4>4.2 Les défis du Shadow Mapping</h4>\r\n          <p>\r\n            Bien que puissante, cette technique présente des défis techniques, notamment les effets d'aliasing et le phénomène d'auto-ombrage (self-shadowing). Pour minimiser ces artefacts, j’ai exploré des techniques d’amélioration comme le filtrage bilinéaire et la correction de biais. L’optimisation de la résolution de la Shadow Map et l'ajustement du volume de projection sont également des points clés pour obtenir des ombres nettes et précises.\r\n          </p>\r\n        </div>\r\n\r\n        <div className={styles.paragraph_50}>\r\n            <img className={styles.paragraph_100} src={process.env.PUBLIC_URL + '/data/images/ShadowMap.png'} alt=\"ShadowMap.png\"></img>\r\n        </div>\r\n\r\n        <div className={styles.paragraph_100}>\r\n          \r\n        </div>\r\n\r\n        <div className={styles.paragraph_100}>\r\n          <h4>4.3 Les applications du Shadow Mapping</h4>\r\n          <p>\r\n            Le Shadow Mapping est largement utilisé dans les jeux vidéo et les simulations pour donner un aspect réaliste aux environnements 3D. Grâce à l'expérience acquise en implémentant cette technique, j'ai pu mieux comprendre comment les ombres contribuent à la perception de la profondeur et du volume dans une scène. Cela m'a également permis d'explorer des concepts avancés comme les ombres dynamiques et la gestion des sources de lumière multiples.\r\n          </p>\r\n        </div>\r\n\r\n    <h3 className={styles.subtitle}>5. Liens des sites utilisés</h3>\r\n    <div className={styles.paragraph_100}>\r\n        <p>Voici quelques ressources en ligne qui m'ont été particulièrement utiles pour mener à bien ce projet :</p>\r\n        <ul>\r\n            <li><a href=\"https://www.opengl.org/\" target=\"_blank\">OpenGL</a> Le site officielle qui dispose déjà d'une très bonne docummentation.</li>\r\n            <li><a href=\"https://learnopengl.com/\" target=\"_blank\">LearnOpenGL</a> - Un excellent site pour apprendre les bases d'OpenGL avec des tutoriels détaillés sur les shaders, l'éclairage et les techniques de rendu avancées.</li>\r\n            <li><a href=\"https://www.opengl-tutorial.org/\" target=\"_blank\">OpenGL Tutorial</a> - Une autre ressource de qualité pour des tutoriels pas à pas sur la programmation 3D avec OpenGL.</li>\r\n      </ul>\r\n    </div>\r\n\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default page;","import React from 'react';\r\nimport styles from './videoMP4.module.css'; \r\n\r\nconst videoMP4 = ({ filePath }) => {\r\n  return (\r\n    <div className={styles.videoContainer}>\r\n      <video \r\n        className={styles.video} \r\n        controls\r\n\r\n      >\r\n        <source src={filePath} type=\"video/mp4\" />\r\n        Votre navigateur ne supporte pas la balise vidéo.\r\n      </video>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default videoMP4;\r\n","// extracted by mini-css-extract-plugin\nexport default {\"article\":\"Article_article__+gNQy\",\"subtitle\":\"Article_subtitle__lXQXQ\",\"paragraph_50\":\"Article_paragraph_50__pJ95J\",\"padding1em\":\"Article_padding1em__kEm6Q\",\"paragraph_100\":\"Article_paragraph_100__LJbdS\",\"margincontent\":\"Article_margincontent__+cw48\",\"maxcontent\":\"Article_maxcontent__umvPg\",\"list\":\"Article_list__KhP-C\"};","// extracted by mini-css-extract-plugin\nexport default {\"videoContainer\":\"videoMP4_videoContainer__jR5fp\",\"video\":\"videoMP4_video__LG6aT\"};"],"names":["_ref","videoId","embedUrl","concat","_jsx","className","styles","videoContainer","children","video","src","title","allow","allowFullScreen","page","_jsxs","article","VideoMP4","filePath","process","paragraph_50","padding1em","paragraph_100","subtitle","href","alt","margincontent","target","controls","type"],"sourceRoot":""}